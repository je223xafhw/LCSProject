# -*- coding: utf-8 -*-
"""marctest-april-june-2019-network-flows.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DLQADtv3bxdJlkx7ofFQfsf5U-Y6AtD9
"""

from mpl_toolkits.mplot3d import Axes3D
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt # plotting
import numpy as np # linear algebra
import os # accessing directory structure
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import matplotlib.pylab as plt
import seaborn as sns
import ipaddress

def make_bytes_plot(df) -> plt.figure:
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(nrows=2, ncols=2, figsize=(12,12))
    range_for_ip_bytes = range(0, 100000, 10000)
    range_for_bytes = range(0, 100, 100)
    ax1.set_xticks(range_for_ip_bytes)
    ax1.set_yticks(range_for_ip_bytes)
    ax3.set_xticks(range_for_ip_bytes)
    ax3.set_yticks(range_for_ip_bytes)
    ax2.set_yticks(range_for_bytes)
    ax2.set_xticks(range(0, 100, 10))
    ax4.set_yticks(range_for_bytes)
    ax4.set_xticks(range(0, 100, 10))
    sns.scatterplot(data=df, x='orig_ip_bytes', y='resp_ip_bytes', hue='label', ax=ax1)
    sns.scatterplot(data=df, x='orig_ip_bytes', y='resp_ip_bytes', hue='proto', ax=ax3)
    sns.scatterplot(data=df, x='orig_bytes', y='resp_bytes', hue='label', ax=ax2)
    sns.scatterplot(data=df, x='orig_bytes', y='resp_bytes', hue='proto', ax=ax4)
    return fig

def make_port_plot(df):
    fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(12,6))
    sns.scatterplot(data=df, x='orig_p', y='resp_p', hue='label', ax=ax1)
    sns.scatterplot(data=df, x='orig_p', y='resp_p', hue='proto', ax=ax2)
    return fig

nRowsRead = None # specify 'None' if want to read whole file

fields=["ts","uid","orig_h","orig_p","resp_h","resp_p","proto","service","duration","orig_bytes","resp_bytes","conn_state","local_orig","local_resp","missed_bytes","history","orig_pkts","orig_ip_bytes","resp_pkts","resp_ip_bytes","tunnel_parents","label","detailed-label"]
df1 = pd.read_csv('https://mcfp.felk.cvut.cz/publicDatasets/IoTDatasets/CTU-IoT-Malware-Capture-1-1/bro/conn.log.labeled',skipfooter=1, engine="python",names=fields, sep="\x09|\x20\x20\x20", skiprows=8, nrows = nRowsRead)
df1.dataframeName = 'CTU-IoT-Malware-Capture-1-1'
nRow, nCol = df1.shape
print(f'There are {nRow} rows and {nCol} columns')

df1.dtypes

def to_ipaddress(params):
    ips:int = []
    for i in params:
        ips.append(int(ipaddress.IPv4Address(i)))
        
    return ips

def to_float(params):
    ips = []
    for i in params:
        value = None
        try: 
            value = float(i)
        except:
            value = None
        ips.append(value)
    return ips

def to_int(params):
    ips = []
    for i in params:
        value = None
        try: 
            value = int(i)
        except:
            value = None
        ips.append(value)
    return ips

df1['ts'] = pd.to_datetime(df1['ts'], unit='s')
df1['orig_h'] = to_ipaddress(df1['orig_h'])

df1['resp_h'] = to_ipaddress(df1['resp_h'])
df1['orig_bytes'] = to_int(df1['orig_bytes'])
df1['resp_bytes'] = to_int(df1['resp_bytes'])

df1['duration'] = to_float(df1['duration'])

df1['local_orig'] = df1['local_orig'].astype(bool)
df1['local_resp'] = df1['local_resp'].astype(bool)

df1['tunnel_parents'] = df1['tunnel_parents'].astype(str)


# One hot for porto

# Get one hot encoding of columns porto
one_hot = pd.get_dummies(df1['proto'])
# Drop column B as it is now encoded
# df1 = df1.drop('proto',axis = 1)
# Join the encoded df
df1 = df1.join(one_hot)

df1.dtypes

make_bytes_plot(df1)
plt.savefig('out.png')

pd.set_option('display.max_columns', 500) 
pd.set_option('display.max_rows', 500) 
df1.head(5)

# check for missing values
df1.isna().sum()

df1["label"].value_counts()

x = df1.loc[:, ['resp_p', 'orig_p']].values

# 'resp_h','resp_p', 'icmp', 'tcp', 'udp', 'local_orig', 'local_resp' ,'orig_pkts', 'orig_ip_bytes', 'resp_pkts' ,'resp_ip_bytes'

print(x.shape)

# https://www.section.io/engineering-education/dbscan-clustering-in-python/

from sklearn.neighbors import NearestNeighbors # importing the library
neighb = NearestNeighbors(n_neighbors=2) # creating an object of the NearestNeighbors class
nbrs=neighb.fit(x) # fitting the data to the object
distances,indices=nbrs.kneighbors(x) # finding the nearest neighbours

print(len(distances))

distances = np.sort(distances, axis = 0) # sorting the distances
distances = distances[:, 1] # taking the second column of the sorted distances
plt.rcParams['figure.figsize'] = (5,3) # setting the figure size
plt.plot(distances) # plotting the distances
plt.show() # showing the plot

from sklearn.cluster import DBSCAN
# cluster the data into five clusters
dbscan = DBSCAN(eps = 8, min_samples = 4).fit(x) # fitting the model
labels = dbscan.labels_ # getting the labels

# Plot the clusters
plt.scatter(x[:, 0], x[:,1], c = labels, cmap= "plasma") # plotting the clusters
plt.xlabel("Income") # X-axis label
plt.ylabel("Spending Score") # Y-axis label
plt.show() # showing the plot